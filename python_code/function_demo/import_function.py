#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
---------------------------------------------------------------------------------------------
#   在一行内导入多个模块，可读性不如 多行导入
import os, sys

---------------------------------------------------------------------------------------------

#   import语句的模块顺序，使用一个空行分隔
python标准库模块
python第三方模块
应用程序自定义模块

---------------------------------------------------------------------------------------------

#   from-import语句
在模块里导入指定的模块属性

---------------------------------------------------------------------------------------------

#   多行导入
from os import open, kill, \
                getsid


from os import (open, kill, getsid)

---------------------------------------------------------------------------------------------

#   扩展的import语句（as）

#   使用别名(原名太长，或者有相同的模块名有冲突)
import longmodulename
short = longmodulename
del longmodulename

import os
from os import open

#   可以替换为

import os as os_modu
from os import open as open_func

---------------------------------------------------------------------------------------------

#   载入时执行模块
#   加载模块会导致这个模块被“执行”，也就是被导入模块的顶层代码被直接执行，这通常包括设定全局变量以及类和函数的声明，如果有检查__name__的操作，那么它也会被执行
#   明确的说，只把函数和模块定义放入模块的顶层是良好的模块编程习惯

---------------------------------------------------------------------------------------------

#   导入（import）和 加载（load）

#   一个模块只被加载一次，无论它被导入多少次，这可以阻止多重导入时代码被多次执行

---------------------------------------------------------------------------------------------

#   导入到当前名称空间的名称

#   调用from-import 可以把名字导入当前的名称空间，这意味着你不需要使用属性、句点属性标识来访问模块的标识符，

例如：你要访问模块module中的var名字：
from module import var

---------------------------------------------------------------------------------------------

#   使用单个的var就可以访问它本身，把var导入到空间名称后就没必要引用模块了，你也可以把指定模块的所有名称导入到当前名称空间里

限制使用：
from module import *
因为：
1.它污染当前名称空间，可能覆盖当前名称空间中现有的名字
2.但如果某个模块有很多要经常访问的变量或者模块名字很长，也可以使用import *

使用 import * 的场景：
1.目标模块中的属性非常多，反复键入模块名很不方便
2.在交互解释器下，可以减少输入次数

---------------------------------------------------------------------------------------------

#   被导入到导入者作用域的名字

1.只从模块导入名字的另一个副作用是：那些名字会成为局部名称空间的一部分，可能导致覆盖一个已经存在的具有相同名字的对象
2.这些变量的改变只影响它的局部拷贝而不是所导入模块的原始名称空间
3.绑定只是局部的而不是整个名称空间

vim imptee.py

foo = 'abc'
def show():
    print 'foo from imptee:', foo

vim impter.py

from imptee import foo, show
show()
foo = 123
print 'foo from impter:', foo
show()

---------------------------------------------------------------------------------------------

vim impter.py

import imptee
imptee.show()
imptee.foo = 123
print 'foo from impter:', imptee.foo
imptee.show()

---------------------------------------------------------------------------------------------

#   模块内建函数

#   __import__()
#   import语句相当于调用了  __import__()函数
#   提供这个函数：是为了让有特殊需要的用户覆盖它，实现自定义的导入算法

sys = __import__('sys')
__import__?

---------------------------------------------------------------------------------------------

#   globals() 和 locals()

globals()   返回调用者全局名称空间的字典
locals()    返回调用者局部名称空间的字典

在一个函数内部，局部名称空间代表：在函数执行时候定义的所有名字，locals（）函数返回的就是包含这些名字的字典，globals（）会返回函数可访问的全局名字

在全局名称空间下，globals（）和locals（）返回相同的字典，因为这时的局部名称空间就是全局空间

def foo():
    print '\ncalling foo()...'
    aString = 'bar'
    anInt = 42
    print "foo()'s globals:", globals().keys()
    print "foo()'s locals:", locals().keys()
print "__main__'s globals:", globals().keys()
print "__main__'s globals:", globals().keys()
foo()

---------------------------------------------------------------------------------------------

#   reload()

这个函数可以重新导入一个已经导入的模块

reload(module)

#   module是你想要重新导入的模块，首先模块必须是全部导入（不是使用 from-import）,而且它必须是被成功导入

#   reload()函数的参数必须是模块自身而不是包含模块名的字符串，也就是类似reload(sys)而不是reload('sys')

#   模块中的代码在导入时被执行，但只执行一次，以后执行import语句不会再次执行这些代码，只是绑定模块名称，而reload（）函数不同

---------------------------------------------------------------------------------------------

#   __init__.py 文件是  初始化模块

#   from-import 语句导入 子包时需要用到它，如果没有用到，它们可以是空文件，从2.5开始，如果忘记为包目录添加__init__.py文件，会导致一个ImportWarning信息

---------------------------------------------------------------------------------------------

#   使用from-import 导入包

from package.module import *

#   在 __init__.py 中加入  __all__变量，该变量包含执行这样的语句时应该导入的模块的名字，它由一个模块名字符串列表组成

---------------------------------------------------------------------------------------------

#   绝对导入

#   很多情况下导入子包会导致和真正的标准库模块发生冲突（事实上是它们的名字）

#   包模块会把名字相同的标准库模块隐藏掉，因为它首先在包内执行相对导入，隐藏掉标准库模块

#   为此，所有的导入现在都被认为是绝对的，也就是说这些名字必须通过python路径（sys.path 或 PYTHONPATH）来访问

import Phone.Mobile.Analog

#   python 2.7 开始，绝对导入 成为  默认功能
#   从2.5开始，可以从__future__导入absolute_import

---------------------------------------------------------------------------------------------

#   相对导入

#   .   代表当前模块
#   ..  代表上层模块
#   ... 代表上上层模块

import Analog
from Analog import dial

from Phone.Mobile.Analog import dial
from .Analog import dial
from ..common_util import setup
from ..Fax import G3.dial

---------------------------------------------------------------------------------------------

#   自动载入的模块

#   在python解释器在标准模式下启动时，一些模块会被自动导入，用于系统相关操作
#   唯一一个影响你的是__builtin__模块，和__builtins__模块相同
#   sys.modules  表示当前载入的模块组成的字典

import sys
sys.modules.keys()

---------------------------------------------------------------------------------------------

#   阻止属性导入

#   如果不想导入某个属性，加上一个下划线

#   不过如果你导入了整个模块  或者  你显式地导入某个属性（import foo._bar），这个隐藏数据的方法就不起作用了

---------------------------------------------------------------------------------------------

#   1.如果是绝对导入，一个模块只能导入自身的子模块或和它的顶层模块同级别的模块及其子模块
#   2.如果是相对导入，一个模块必须有包结构且只能导入它的顶层模块内部的模块

#   如果一个模块被直接运行，则它自己为顶层模块，不存在层次结构，所以找不到其他的相对路径。

#   Python2.x 缺省为相对路径导入，Python3.x 缺省为绝对路径导入。绝对导入可以避免导入子包覆盖掉标准库模块（由于名字相同，发生冲突）。如果在 Python2.x 中要默认使用绝对导入，可以在文件开头加入如下语句：

from __future__ import absolute_import

import bench     # 此为 implicit relative import
from . import bench   # 此为 explicit relative import
from furniture import bench # 此为 absolute import

#   隐式相对就是没有告诉解释器相对于谁，但默认相对与当前模块；而显示相对则明确告诉解释器相对于谁来导入。以上导入方式的第三种，才是官方推荐的，第一种是官方强烈不推荐的，Python3 中已经被废弃，这种方式只能用于导入 path 中的模块。

#   最后再次强调，相对导入与绝对导入仅针对于包内导入而言，要不然本文所讨论的内容就没有意义。所谓的包，就是包含   __init__.py   文件的目录，该文件在包导入时会被首先执行，该文件可以为空，也可以在其中加入任意合法的 Python 代码。

#   相对导入可以避免硬编码，对于包的维护是友好的。绝对导入可以避免与标准库命名的冲突，实际上也不推荐自定义模块与标准库命令相同。

#   要运行包中包含绝对导入和相对导入的模块，可以用 python -m A.B.C 告诉解释器模块的层次结构

#   有人可能会问：假如有两个模块 a.py 和 b.py 放在同一个目录下，为什么能在 b.py 中 import a 呢？

#   这是因为这两个文件所在的目录不是一个包，那么每一个 python 文件都是一个独立的、可以直接被其他模块导入的模块，就像你导入标准库一样，它们不存在相对导入和绝对导入的问题。相对导入与绝对导入仅用于包内部。

---------------------------------------------------------------------------------------------

"""
